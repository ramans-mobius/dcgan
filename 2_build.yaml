name: Initialize GAN Model
description: Initializes either DCGAN or Vanilla GAN based on configuration.
inputs:
  - name: gan_config
    type: String
    description: "GAN configuration (specifies model_type: 'dcgan' or 'vanilla_gan')"
outputs:
  - name: model
    type: Model
  - name: init_config
    type: String
    description: "Initialization configuration"
implementation:
  container:
    image: gurpreetgandhi/nesy-factory:v33
    command:
      - sh
      - -c
      - |
        # Install dependencies
        pip install torch torchvision --quiet
        echo "Dependencies installed for GAN initialization"
        
        python -c "
        import sys, os, pickle, json, torch
        
        print('Starting GAN Model Initialization (DCGAN or Vanilla GAN)')
        
        # Parse arguments
        gan_config_str = sys.argv[1]
        model_path = sys.argv[2]
        init_config_path = sys.argv[3]
        
        print('GAN config length: ' + str(len(gan_config_str)))
        
        # Parse GAN configuration
        try:
            gan_config = json.loads(gan_config_str)
        except json.JSONDecodeError as e:
            print('JSON parse error: ' + str(e))
            # Try cleaning
            try:
                cleaned = gan_config_str.strip()
                if cleaned.startswith('\"') and cleaned.endswith('\"'):
                    cleaned = cleaned[1:-1]
                cleaned = cleaned.replace('\\\\\"', '\"').replace('\\\"', '\"')
                gan_config = json.loads(cleaned)
                print('Parsed after cleaning')
            except Exception as e2:
                print('Failed to parse config: ' + str(e2))
                # Default to DCGAN
                gan_config = {
                    'model_type': 'dcgan',
                    'image_size': 64,
                    'channels': 3,
                    'latent_dim': 100,
                    'training_algorithm': 'backprop'
                }
        
        # Determine model type
        model_type = gan_config.get('model_type', 'dcgan').lower()
        is_dcgan = model_type == 'dcgan'
        is_vanilla_gan = model_type == 'vanilla_gan'
        
        if not (is_dcgan or is_vanilla_gan):
            print('Warning: Unknown model type ' + model_type + '. Defaulting to DCGAN.')
            model_type = 'dcgan'
            is_dcgan = True
            gan_config['model_type'] = 'dcgan'
        
        print(model_type.upper() + ' Configuration:')
        
        if is_dcgan:
            print('  Image Size: ' + str(gan_config.get('image_size', 64)))
            print('  Channels: ' + str(gan_config.get('channels', 3)))
            print('  Latent Dim: ' + str(gan_config.get('latent_dim', 100)))
        else:  # Vanilla GAN
            print('  Input Dim: ' + str(gan_config.get('input_dim', 784)))
            print('  Latent Dim: ' + str(gan_config.get('latent_dim', 100)))
        
        print('  Training Algorithm: ' + gan_config.get('training_algorithm', 'backprop'))
        
        # Try to import both GAN types
        dcgan_available = False
        vanilla_gan_available = False
        
        try:
            from nesy_factory.GANs.dcgan import DCGAN, DCGANConfig
            dcgan_available = True
            print('DCGAN module available')
        except ImportError as e:
            print('DCGAN import error: ' + str(e))
        
        try:
            from nesy_factory.GANs.vanilla_gan import VanillaGAN, VanillaGANConfig
            vanilla_gan_available = True
            print('Vanilla GAN module available')
        except ImportError as e:
            print('Vanilla GAN import error: ' + str(e))
        
        # If imports failed, try alternative paths
        if not dcgan_available or not vanilla_gan_available:
            try:
                sys.path.insert(0, '/app')
                if not dcgan_available:
                    from GANs.dcgan import DCGAN, DCGANConfig
                    dcgan_available = True
                    print('DCGAN imported from alternative path')
                if not vanilla_gan_available:
                    from GANs.vanilla_gan import VanillaGAN, VanillaGANConfig
                    vanilla_gan_available = True
                    print('Vanilla GAN imported from alternative path')
            except ImportError as e:
                print('Alternative import also failed: ' + str(e))
        
        # Create model based on type
        try:
            if is_dcgan and dcgan_available:
                # Create DCGAN configuration
                dcgan_config_dict = {
                    'image_size': gan_config.get('image_size', 64),
                    'channels': gan_config.get('channels', 3),
                    'latent_dim': gan_config.get('latent_dim', 100),
                    'training_algorithm': gan_config.get('training_algorithm', 'backprop'),
                    'use_forward_forward': gan_config.get('training_algorithm', '') == 'forward_forward',
                    'use_cafo': gan_config.get('training_algorithm', '') == 'cafo',
                    'generator_layers': gan_config.get('generator_layers', None),
                    'discriminator_layers': gan_config.get('discriminator_layers', None),
                    'batch_size': gan_config.get('batch_size', 32),
                    'learning_rate': gan_config.get('learning_rate', 0.0002),
                    'epochs': gan_config.get('epochs', 50),
                    'device': 'cuda' if torch.cuda.is_available() else 'cpu'
                }
                
                # Create config object
                dcgan_config = DCGANConfig(**dcgan_config_dict)
                print('Created DCGAN config')
                
                # Create DCGAN model
                gan_model = DCGAN(dcgan_config)
                print('Created DCGAN model')
                
            elif is_vanilla_gan and vanilla_gan_available:
                # Create Vanilla GAN configuration
                vanilla_config_dict = {
                    'input_dim': gan_config.get('input_dim', 784),
                    'latent_dim': gan_config.get('latent_dim', 100),
                    'training_algorithm': gan_config.get('training_algorithm', 'backprop'),
                    'use_forward_forward': gan_config.get('training_algorithm', '') == 'forward_forward',
                    'use_cafo': gan_config.get('training_algorithm', '') == 'cafo',
                    'generator_layers': gan_config.get('generator_layers', [256, 512]),
                    'discriminator_layers': gan_config.get('discriminator_layers', [512, 256]),
                    'batch_size': gan_config.get('batch_size', 64),
                    'lr': gan_config.get('learning_rate', 0.0002),
                    'epochs': gan_config.get('epochs', 50),
                    'device': 'cuda' if torch.cuda.is_available() else 'cpu'
                }
                
                # Create config object
                vanilla_config = VanillaGANConfig(**vanilla_config_dict)
                print('Created Vanilla GAN config')
                
                # Create Vanilla GAN model
                gan_model = VanillaGAN(vanilla_config)
                print('Created Vanilla GAN model')
                
            else:
                # Create mock model for testing
                print('Creating mock GAN model for ' + model_type.upper())
                class MockGANConfig:
                    def __init__(self, **kwargs):
                        self.__dict__.update(kwargs)
                    def to_dict(self):
                        return self.__dict__
                
                class MockGAN:
                    def __init__(self, config):
                        self.config = config
                        self.generator = None
                        self.discriminator = None
                
                gan_model = MockGAN(MockGANConfig(**gan_config))
                print('Created mock ' + model_type.upper() + ' model for testing')
            
            # Get parameter counts if available
            if hasattr(gan_model, 'generator') and gan_model.generator:
                gen_params = sum(p.numel() for p in gan_model.generator.parameters())
                print('Generator parameters: ' + str(gen_params))
            
            if hasattr(gan_model, 'discriminator') and gan_model.discriminator:
                disc_params = sum(p.numel() for p in gan_model.discriminator.parameters())
                print('Discriminator parameters: ' + str(disc_params))
                
        except Exception as e:
            print('Error creating ' + model_type.upper() + ': ' + str(e))
            # Create a simple mock model
            class MockGAN:
                def __init__(self, config):
                    self.config = config
                    self.generator = None
                    self.discriminator = None
            gan_model = MockGAN(gan_config)
            print('Created mock ' + model_type.upper() + ' model for testing')
        
        # Save model
        output_dir = os.path.dirname(model_path)
        if output_dir and not os.path.exists(output_dir):
            os.makedirs(output_dir, exist_ok=True)
        
        with open(model_path, 'wb') as f:
            pickle.dump(gan_model, f)
        
        # Save initialization config
        init_config = {
            'model_created': True,
            'model_type': model_type,
            'success': True,
            'device': 'cuda' if torch.cuda.is_available() else 'cpu'
        }
        
        # Add model-specific info
        if is_dcgan:
            init_config.update({
                'image_size': gan_config.get('image_size', 64),
                'channels': gan_config.get('channels', 3),
                'latent_dim': gan_config.get('latent_dim', 100),
            })
        else:  # Vanilla GAN
            init_config.update({
                'input_dim': gan_config.get('input_dim', 784),
                'latent_dim': gan_config.get('latent_dim', 100),
                'generator_layers': gan_config.get('generator_layers', [256, 512]),
                'discriminator_layers': gan_config.get('discriminator_layers', [512, 256]),
            })
        
        init_config['training_algorithm'] = gan_config.get('training_algorithm', 'backprop')
        
        output_dir_config = os.path.dirname(init_config_path)
        if output_dir_config and not os.path.exists(output_dir_config):
            os.makedirs(output_dir_config, exist_ok=True)
        
        with open(init_config_path, 'w') as f:
            json.dump(init_config, f, indent=2)
        
        print(model_type.upper() + ' Model Initialization Complete')
        print('Saved model to: ' + model_path)
        " "$0" "$1" "$2"
    args:
      - {inputValue: gan_config}
      - {outputPath: model}
      - {outputPath: init_config}
